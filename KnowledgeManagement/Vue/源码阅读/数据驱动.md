**Vueå®šä¹‰**

```js
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
```

ç”¨ `instanceof` åˆ¤æ–­æ˜¯å¦ä½¿ç”¨ `new` è°ƒç”¨ã€‚

**åˆå§‹åŒ–**

```js
initMixin(Vue) // æŒ‚è½½_initæ–¹æ³•
stateMixin(Vue) // æŒ‚è½½ $data/$props/$set/$delete/$watchç­‰å±æ€§
eventsMixin(Vue) // æŒ‚è½½ $on/$once/$off/$emitç­‰æ–¹æ³•
lifecycleMixin(Vue) // æŒ‚è½½ _update/$forceUpdate/$destroy ç­‰æ–¹æ³• *
renderMixin(Vue) // æŒ‚è½½æ¸²æŸ“ç›¸å…³çš„å¸®åŠ©å‡½æ•°ï¼Œ$nextTick/_renderç­‰æ–¹æ³• *

// å¸¦ * å·çš„æ˜¯æœ‰äº›åœ°æ–¹ä¸å¤ªç†Ÿï¼Œä¸å¤ªäº†è§£çš„ï¼Œæ¯”å¦‚_updateå’Œ_renderï¼Œè¿˜æœ‰æ¸²æŸ“ç›¸å…³çš„å‡½æ•°(installRenderHelpersè¿™ä¸ªæ–¹æ³•é‡Œåšçš„äº‹)
```

**_initæ–¹æ³•**

```js
Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // ä½¿ç”¨å¦‚ä¸‹æ–¹å¼åšä¸€ä¸ªå…¨å±€çš„uidæ§åˆ¶ï¼Œåªéœ€è¦ä¸€ç›´é€’å¢å³å¯
    // æ¯æ¬¡â€œå®ä¾‹åŒ–â€æ—¶éƒ½æ˜¯ä»0å¼€å§‹ï¼Œæœ¬æ¬¡ä½¿ç”¨ä¿è¯å…¨å±€å”¯ä¸€å³å¯ã€‚
    // å¦‚æœéœ€è¦æŒä¹…åŒ–ï¼Œè¿™ç§æ–¹å¼ä¸é€‚åˆï¼Œéƒ¨åˆ†ä¸šåŠ¡åœºæ™¯å¯ä»¥è€ƒè™‘ä½¿ç”¨ã€‚
    vm._uid = uid++

    // æ€§èƒ½è®°å½•ç›¸å…³ï¼Œæš‚æ—¶ä¸çœ‹
    let startTag, endTag
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // ç”¨äºæ ‡è®° vm ä¸éœ€è¦è¢«è§‚å¯Ÿ
    vm._isVue = true
    // åˆå¹¶ options(new Vueè°ƒç”¨æ—¶ä¼ å…¥çš„options)
    // è¿™ä¸ª isComponent æ ‡è¯†ä¸çŸ¥é“æœ‰ä»€ä¹ˆç”¨ï¼Œoptionsæ˜¯ä¼ å…¥çš„ï¼Œè¿™ä¸ªæ ‡è¯†åœ¨ä¼ å…¥çš„æ—¶å€™æ‰‹å†™å—ï¼Ÿ
    // ä¹Ÿæ²¡çœ‹åˆ°å“ªä¸ªåœ°æ–¹åšäº†é»˜è®¤å€¼åˆå¹¶
    if (options && options._isComponent) {
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }

    // åˆå§‹åŒ–æ•°æ®å“åº”
    // PSï¼šæˆ‘çœ‹çš„æ˜¯v2.6.11ç‰ˆæœ¬çš„æºç 
    // åœ¨è¿™ä¸ªç‰ˆæœ¬ä¸­ï¼Œå·²ç»å¼€å§‹å°è¯•ç”¨proxy APIæ¥åšæ•°æ®å“åº”å¤„ç†äº†
    // æš‚æ—¶å…ˆä¸çœ‹è¿™ä¸€å—
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }

    // åªçœ‹åˆ°å£°æ˜ï¼Œæ²¡çœ‹åˆ°ä½¿ç”¨
    vm._self = vm

    // åˆå§‹åŒ–è¿‡ç¨‹
    // æŒ‚è½½ $parent/$root/$children/$refsç­‰ï¼Œä»¥åŠä¸€äº›æ ‡è¯† *
    initLifecycle(vm)
    // è¿™å—æœ‰ç‚¹å¤šï¼Œæ²¡å¤ªçœ‹æ‡‚ï¼Œè¿‡
    initEvents(vm)
    // åˆå§‹åŒ–æ¸²æŸ“ç›¸å…³å‡½æ•°ï¼ŒåŒ…æ‹¬_cå’Œ$createElementè¿™äº›
    initRender(vm)
    callHook(vm, 'beforeCreate')
    // è¿‡
    initInjections(vm)
    // åˆå§‹åŒ–props/methods/data/computed/watch
    // è¿™ä¸ªåˆå§‹åŒ–é¡ºåºï¼Œæ˜¯ä¸æ˜¯ä¹Ÿä¼šæœ‰å½±å“ï¼Ÿè¿˜æ˜¯è¯´EYå°±åªæ˜¯åƒè¿™æ ·å†™ä¸‹æ¥äº†
    // å› ä¸ºè¿™éƒ¨åˆ†åˆå§‹åŒ–åœ¨ call beforeCreate ä¹‹å
    // æ‰€ä»¥åœ¨beforeCreateç”Ÿå‘½å‘¨æœŸé‡Œï¼Œæ‹¿ä¸åˆ°dataç­‰å±æ€§çš„åŸå› 
    initState(vm)
    // è¿‡
    initProvide(vm) // resolve provide after data/props
    callHook(vm, 'created')

    // è®°å½•åˆå§‹åŒ–æ€§èƒ½æ¶ˆè€—
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }

    if (vm.$options.el) {
      // æ‡µé€¼äº†ï¼Œçªç„¶å‡ºç°$mountçš„è°ƒç”¨
      // å‚è€ƒé»„è½¶çš„æ–‡ç« ï¼Œå»äº†è§£ entry-runtime-with-compiler é‡Œçš„å®šä¹‰
      vm.$mount(vm.$options.el)
    }
  }
```

**$mount**

`$mount` ä¸­ä½¿ç”¨çš„æŸ¥è¯¢ï¼Œæ‰€ä»¥ä¼ å…¥çš„ `el` æ”¯æŒæœ‰æ•ˆçš„é€‰æ‹©å™¨å­—ç¬¦ä¸²ï¼Œæˆ–ç›´æ¥ä¼ å…¥ dom å…ƒç´ èŠ‚ç‚¹ã€‚

```js
function query (el: string | Element): Element {
  if (typeof el === 'string') {
    const selected = document.querySelector(el)
    if (!selected) {
      process.env.NODE_ENV !== 'production' && warn(
        'Cannot find element: ' + el
      )
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}
```

`$mount` æºç ï¼Œåˆ é™¤äº†æ€§èƒ½è®°å½•ç›¸å…³éƒ¨åˆ†ã€‚

```js
// æœ€åreturnè°ƒç”¨çš„mountæ˜¯ runtime/indexé‡Œå®šä¹‰çš„mountæ–¹æ³•
// æ‰€ä»¥è¿™é‡Œæ˜¯Webå¹³å°ä¸‹çš„ï¼Œå¯¹å‚æ•°çš„ä¸€äº›æ ¡éªŒå’Œé¢„å¤„ç†
const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)

  // ç›®æ ‡æŒ‚è½½èŠ‚ç‚¹ä¸èƒ½æ˜¯ html æˆ– body
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    // ä¸Šä¸€æ®µä¸»è¦æ˜¯æ ¹æ®template/elè·å–HTMLå†…å®¹ï¼Œæ²¡æœ‰çœ‹çš„ç‰¹åˆ«ç»†
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    
    // æ ¹æ®è·å–åˆ°çš„templateç”Ÿæˆrenderå‡½æ•°
    // ç¨å¾®çœ‹äº†ä¸€ä¸‹ï¼Œå†…å®¹æœ‰ç‚¹å¤šï¼ŒæŒ‰ç…§é»„è½¶çš„è®²è§£ï¼Œå…ˆè·³è¿‡è¿™éƒ¨åˆ†
    if (template) {
      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns
    }
  }
  // æŠ˜å äº†ä¸Šé¢ifçš„éƒ¨åˆ†åï¼Œçœ‹åˆ°è¿™é‡Œè°ƒç”¨äº†callï¼Œä¸ä¼šæ­»å¾ªç¯å—ï¼Ÿ
  return mount.call(this, el, hydrating)
}
```

**mount**

```js
export const inBrowser = typeof window !== 'undefined'

Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  // æ ¸å¿ƒè°ƒç”¨
  return mountComponent(this, el, hydrating)
}
```

**mountComponent**

```js
function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  if (!vm.$options.render) {
    // é˜²æ­¢renderä¸å­˜åœ¨
    // å¦‚æœå‚æ•°ä¼ é€’æ²¡å‡ºé”™çš„æƒ…å†µä¸‹ï¼Œrenderåº”è¯¥æ˜¯å¿…æœ‰çš„
    // ä»¥ä¸‹é”™è¯¯æƒ…å†µçš„æ ¡éªŒæš‚æ—¶ä¸çœ‹ï¼Œåªå…³å¿ƒä¸»æµç¨‹
    vm.$options.render = createEmptyVNode
    if (process.env.NODE_ENV !== 'production') {
      // ä¸çŸ¥é“åœ¨è·å–templateé‚£ä¸€æ®µæœ‰æ²¡æœ‰æ›´æ–°templateæˆ–el
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        )
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        )
      }
    }
  }

  // çœ‹åˆ°è¿™é‡Œçªç„¶æƒ³èµ·æ¥ï¼ŒbeforeCreateé’©å­ä¸èƒ½è·å–data
  // ç„¶åè¿”å›å»çœ‹äº†ä¸€ä¸‹ call beforeCreate åšäº†æ–°è®°å½•
  callHook(vm, 'beforeMount')

  let updateComponent
  // if æˆç«‹å°†ä¼šè®°å½•æ€§èƒ½å¼€é”€ï¼Œç›´æ¥çœ‹else
  if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
    updateComponent = () => {
      const name = vm._name
      const id = vm._uid
      const startTag = `vue-perf-start:${id}`
      const endTag = `vue-perf-end:${id}`

      mark(startTag)
      const vnode = vm._render()
      mark(endTag)
      measure(`vue ${name} render`, startTag, endTag)

      mark(startTag)
      vm._update(vnode, hydrating)
      mark(endTag)
      measure(`vue ${name} patch`, startTag, endTag)
    }
  } else {
    updateComponent = () => {
      // _updateä¸º_initä¹‹åï¼Œè°ƒç”¨lifecycleMixinåŠ è½½
      // ç”¨vscodeçš„è·³è½¬ï¼Œè·³åˆ°é”™è¯¯çš„ä½ç½®äº†
      // å¦‚æœä¸æ˜¯åœ¨å‰é¢çœ‹äº†ä¸Šé¢è¿™ä¸ªæ–¹æ³•çš„è°ƒç”¨ï¼Œå¯èƒ½å°±æ‡µé€¼äº†
      // ä¸ºä»€ä¹ˆè¿™é‡Œç›´æ¥è°ƒç”¨_renderï¼ˆrenderMixinä¸­åˆå§‹åŒ–ï¼‰
      vm._update(vm._render(), hydrating)
    }
  }

  // å®šä¹‰watch
  // vmæ˜¯å®ä¾‹å¯¹è±¡
  // updateComponentåº”è¯¥æ˜¯å›è°ƒæ–¹æ³•
  //ï¼ˆçœ‹äº†Watcherçš„å®šä¹‰ï¼Œè¿™é‡Œæ˜¯expOrFnï¼Œå°†ä¼šèµ‹å€¼ç»™watcherçš„getterï¼‰
  // noopæ˜¯ä¸€ä¸ªï¼ˆè¿™é‡Œæ‰æ˜¯å›è°ƒï¼‰
  // ç¬¬å››ä¸ªå‚æ•°ä¼ äº†é’©å­å‡½æ•°
  // ç¬¬äº”ä¸ªå‚æ•°ç”¨æ¥å°†è¿™ä¸ªwatcheræŒ‚è½½åˆ°vm._watcherä¸Š
  // æŒ‰ç…§Evançš„æ³¨é‡Šï¼Œæ˜¯é˜²æ­¢åœ¨å­ç»„ä»¶çš„mountedé’©å­ä¸­ï¼Œè°ƒç”¨ $forceUpdateæ–¹æ³•
  // å…·ä½“è¿˜å¾—å†çœ‹
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)

  // è¿™é‡Œä¿®æ”¹ä¸ºfalseæœ‰ä»€ä¹ˆç”¨å—ï¼Ÿ
  hydrating = false

  // è°ƒç”¨é’©å­å‡½æ•°
  // æŒ‰ç…§è¿™é‡Œçš„ä»£ç ï¼Œé¦–æ¬¡ç”Ÿæˆçš„å®ä¾‹æ˜¯æ²¡æœ‰ $vnodeèŠ‚ç‚¹çš„
  if (vm.$vnode == null) {
    // æ ‡è®°ä¸ºå·²æŒ‚è½½
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```

çœ‹åˆ°è¿™é‡Œï¼Œæ•´ä¸ª `new Vue`  è¿‡ç¨‹çš„é‡ç‚¹è¿˜æ˜¯åœ¨ `Watcher` ä¸Šã€‚`_update/_render/Watcher` ä¸‰è€…çš„å®ç°é€»è¾‘ä¸å¤Ÿäº†è§£ï¼Œå¯¼è‡´çœ‹åˆ°è¿™é‡Œï¼Œå¯¹äºæ•´ä¸ªæŒ‚è½½è¿‡ç¨‹çš„å®ç°ï¼Œä»¥åŠæ•°æ®çš„å“åº”è¿˜æ˜¯å¾ˆæ‡µé€¼çš„ã€‚

ç„¶åçœ‹äº†ä»¥ä¸‹é»„è½¶è®²çš„ï¼Œæ¥ä¸‹æ¥ä¹Ÿæ˜¯è¦ä»‹ç» `_update` å’Œ `_render`ã€‚æŒ‰ç…§é»„è½¶çš„é¡ºåºï¼ŒåŠ ä¸Šåœ¨è°ƒç”¨æ—¶ï¼Œä¹Ÿæ˜¯ `_render` ä¼šè¢«å…ˆè°ƒç”¨ï¼Œå…ˆçœ‹ `_render`ã€‚


**_render**

```js
Vue.prototype._render = function (): VNode {
  const vm: Component = this
  const { render, _parentVnode } = vm.$options

  // å¦‚æœæœ‰ _parentVnode åºåˆ—åŒ–æ’æ§½ï¼Œè¿‡
  if (_parentVnode) {
    vm.$scopedSlots = normalizeScopedSlots(
      _parentVnode.data.scopedSlots,
      vm.$slots,
      vm.$scopedSlots
    )
  }

  // æš‚æ—¶ç†è§£ä¸äº†è¿™ä¸€è¡Œçš„ä½œç”¨
  vm.$vnode = _parentVnode


  let vnode
  try {
    // There's no need to maintain a stack because all render fns are called
    // separately from one another. Nested component's render fns are called
    // when parent component is patched.
    // ä¸Šé¢Evançš„æ³¨è§£ä¸æ˜¯å¾ˆçœ‹å¾—æ‡‚ï¼Œä¸»è¦æ˜¯ä¸çŸ¥é“patchedä»£è¡¨çš„æ˜¯ä»€ä¹ˆä¸€ä¸ªè¿‡ç¨‹
    // export let currentRenderingInstanceï¼Œåº”è¯¥åœ¨æŸäº›è¿‡ç¨‹ä¸­ä¼šç”¨åˆ°
    // Vueæºç ä¸­æœ‰è®¸å¤š export letçš„å½¢å¼ï¼Œåº”è¯¥æ˜¯ä¸ºäº†å¤šæ¨¡å—å…¬ç”¨ä¸€ä¸ªå˜é‡
    // ä½†æ˜¯å…·ä½“æ•ˆæœå¾—è‡ªå·±å†™ä¸ª demo å°è¯•ä¸€ä¸‹
    currentRenderingInstance = vm
    // è¿™ä¸ªrenderå°±æ˜¯é‡ç‚¹äº†å§
    vnode = render.call(vm._renderProxy, vm.$createElement)
  } catch (e) {

    // é”™è¯¯å¤„ç†å…ˆä¸çœ‹äº†
    handleError(e, vm, `render`)
    // return error render result,
    // or previous vnode to prevent render error causing blank component
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {
      try {
        vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
      } catch (e) {
        handleError(e, vm, `renderError`)
        vnode = vm._vnode
      }
    } else {
      vnode = vm._vnode
    }
    
  } finally {

    // åœ¨è¿™é‡Œé‡ç½®ä¸º nullï¼Œé‚£åº”è¯¥åœ¨renderè¿‡ç¨‹ä¸­æœ‰ç”¨åˆ°è¿™ä¸ª
    currentRenderingInstance = null
  }

  // ä¸‹é¢è¿™ä¸ª if æ²¡æœ‰å…·ä½“èµ°æµç¨‹ä¸æ˜¯å¾ˆæ˜ç™½
  if (Array.isArray(vnode) && vnode.length === 1) {
    vnode = vnode[0]
  }
  // å¦‚æœè¿”å›çš„ vnode æ•°æ®ä¸å¯¹ï¼Œç”Ÿæˆä¸€ä¸ªEmptyVNodeå¹¶è¿”å›
  // è¿™ä¸€å—å¦‚æœè¦å¼„æ‡‚ï¼Œæ„Ÿè§‰å¾—æŠŠ VNode äº†è§£çš„æ¯”è¾ƒç†Ÿ
  if (!(vnode instanceof VNode)) {
    if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
      warn(
        'Multiple root nodes returned from render function. Render function ' +
        'should return a single root node.',
        vm
      )
    }
    vnode = createEmptyVNode()
  }
  // parentä½¿ç”¨å¾ˆå°‘ï¼Œæ‰€ä»¥è¿™ä¸€å—ç›¸å…³çš„ä»£ç ï¼Œéƒ½ä¸æ˜¯æ€ä¹ˆçœ‹çš„æ‡‚
  vnode.parent = _parentVnode
  return vnode
}
```

çœ‹äº†ä¸€ä¸‹ `render` å¤§è‡´é€»è¾‘ï¼Œæœ€åæ‰¾åˆ°äº† `genElement` æ–¹æ³•ï¼Œä¸çŸ¥é“æ˜¯ä¸æ˜¯æˆ‘æ‰¾é”™äº†ã€‚çœ‹çœ‹é»„è½¶æ˜¯æ€ä¹ˆè¯´çš„ã€‚


```js
vnode = render.call(vm._renderProxy, vm.$createElement)
```

å¯¹è¿™ä¸¤ä¸ªå±æ€§æ²¡æœ‰å°è±¡ï¼Œæ˜¯æˆ‘çœ‹æ¼äº†ï¼Ÿè¿˜æ˜¯åœ¨ `render` è¿‡ç¨‹ä¸­æ·»åŠ çš„ï¼Ÿ

æ˜¯åœ¨ `initProxy` å’Œ `initRender` ä¸­æ·»åŠ çš„ï¼Œåè€…æœ‰å°è±¡ï¼Œå‰è€…å®Œå…¨æ²¡äº†ã€‚

æ‰€ä»¥å°±æ˜¯åœ¨ `vm` ä¸Šè°ƒç”¨ `render` æ–¹æ³•ï¼Œä½†æ˜¯è¿™ä¸ª `render` æ–¹æ³•æ²¡æœ‰å»çœ‹å…·ä½“å®ç°ï¼Œå†…éƒ¨æ˜¯ä»€ä¹ˆå®Œå…¨æŠ“çã€‚

é»„è½¶è¯´è¿™ä¸ªæ—¶å€™å…ˆå¾—äº†è§£ Virtual Domï¼Œä½†æ˜¯æˆ‘è¿˜æ˜¯åšæŒè‡ªå·±çš„å…ˆçœ‹ä¸€ä¸‹ `$createElement` çš„å®ç°ã€‚

**$createElement**

```js
function createElement (
  context: Component,
  tag: any,
  data: any,
  children: any,
  normalizationType: any,
  alwaysNormalize: boolean
): VNode | Array<VNode> {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children
    children = data
    data = undefined
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE
  }
  // é‡ç‚¹åœ¨è¿™ä¸ªæ–¹æ³•äº†ï¼Œä¸Šé¢çš„è½¬æ¢ä¸æ˜¯å¾ˆæ˜ç™½ä½œç”¨
  return _createElement(context, tag, data, children, normalizationType)
}
```

**_createElement**

```js
function _createElement (
  context: Component,
  tag?: string | Class<Component> | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array<VNode> {
  // ä¿è¯æ¯æ¬¡åˆ›å»ºçš„vnodeæ˜¯æ–°çš„ï¼Œè€Œä¸æ˜¯è¢«observedçš„
  if (isDef(data) && isDef((data: any).__ob__)) {
    process.env.NODE_ENV !== 'production' && warn(
      `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n` +
      'Always create fresh vnode data objects in each render!',
      context
    )
    return createEmptyVNode()
  }

  // è¿™æ®µä½œç”¨ä¸æ˜¯å¾ˆæ‡‚
  if (isDef(data) && isDef(data.is)) {
    tag = data.is
  }
  if (!tag) {
    return createEmptyVNode()
  }

  // æ ¡éªŒdataçš„keyæ˜¯å¦è®¾ç½®æ­£ç¡®
  // åªçœ‹åˆ°è¿™é‡Œï¼Œä¸å¤ªæ‡‚æœ‰å“ªäº›å½±å“
  // å…¶å®è¿™ç§åœ°æ–¹ï¼Œå¦‚æœæ˜¯æ ¹æ®æ•´ä¸ªcommitå†å²èµ°çš„
  // åº”è¯¥ä¼šæ›´å¥½ç†è§£ä¸€äº›
  if (process.env.NODE_ENV !== 'production' &&
    isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    if (!__WEEX__ || !('@binding' in data.key)) {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      )
    }
  }
  // å¦‚æœchildrenåªæœ‰ä¸€ä¸ªå¹¶ä¸”æ˜¯ function å½¢å¼
  // å°†è¿™ä¸ªchildä½œä¸ºé»˜è®¤çš„ scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {}
    data.scopedSlots = { default: children[0] }
    children.length = 0
  }

  // æ ¼å¼åŒ–éƒ¨åˆ†ï¼Œå¤§æ¦‚çœ‹äº†ä¸€ä¸‹ï¼Œæ²¡æœ‰ç»†çœ‹
  if (normalizationType === ALWAYS_NORMALIZE) {
    // è¿™é‡Œä¸»è¦æ˜¯æ ¹æ®childrenï¼Œç”ŸæˆTextVNode
    children = normalizeChildren(children)
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    // è¿™ä¸ªä»£ç ç®€å•ï¼Œåè€Œæ²¡æ€ä¹ˆçœ‹æ‡‚
    children = simpleNormalizeChildren(children)
  }

  let vnode, ns
  // tagæ¥æºäºdata.isï¼Œä½†æ˜¯å¹³æ—¶æ²¡æ€ä¹ˆç”¨åˆ°è¿‡è¿™ä¸ªis
  // æ²¡ä»€ä¹ˆå°è±¡
  if (typeof tag === 'string') {
    let Ctor
    // è·å–namespace
    // namespaceä»¥å‰å­¦c#äº†è§£è¿‡ï¼Œä½†æ˜¯å°è±¡ä¸æ·±
    // Vueé‡Œç”¨åˆ°namespaceä¸çŸ¥é“æ˜¯æƒ³æ€ä¹ˆç”¨
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)

    // åˆ¤æ–­æ˜¯ä¸æ˜¯HTMLçš„tag
    if (config.isReservedTag(tag)) {
      // nativeOnåº”è¯¥æ˜¯åœ¨åˆå§‹åŒ–dataçš„æ—¶å€™åšäº†å¤„ç†
      // åœ¨çœ‹çš„è¿‡ç¨‹ä¸­ï¼Œå¯¹è¿™ä¸ªå±æ€§æ²¡æœ‰å°è±¡
      if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn)) {
        warn(
          `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,
          context
        )
      }

      // ~~å¦‚æœæ²¡æœ‰ä½¿ç”¨v-on~~
      // åº”è¯¥æ˜¯ï¼Œå³ä½¿ç”¨äº†v-onï¼Œä¹Ÿä¼šåˆ›å»ºVNode
      // æš‚æ—¶ä¸çœ‹VNodeï¼Œç¬¬ä¸€ä¸ªå‚æ•°æš‚æ—¶ä¸çŸ¥é“ä½œç”¨
      // ä½†çœ‹å¾—å‡ºæ¥æ˜¯æ ¹æ®åŸç”ŸTagåšäº†å¤„ç†
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )

    // è¿™ä¸ªåº”è¯¥æ˜¯èŠ‚ç‚¹è¢«æ ‡è®°ä¸ºv-preçš„æƒ…å†µä¸‹
    // æš‚æ—¶å…ˆä¸ç®¡
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      // ğŸ‘†çš„æ³¨é‡Šä¸æ˜¯å¾ˆèƒ½æ˜ç™½
      // åˆ¤æ–­å®Œä¸Šé¢ä¸¤ç§æƒ…å†µï¼Œå‰©ä¸‹çš„ç›´æ¥åˆ›å»ºVNode
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    // è¿™é‡Œæ˜¯åº”è¯¥æ˜¯åˆ›å»ºç»„ä»¶
    vnode = createComponent(tag, data, context, children)
  }
  // tag === 'string'ï¼Ÿï¼Ÿ è¿™åˆçš„çœ‹dataçš„è½¬æ¢éƒ¨åˆ†ï¼Ÿï¼Ÿ
  // å› ä¸ºelseæ˜¯åˆ›å»ºç»„ä»¶ï¼Œtagéš¾é“ä¸éƒ½æ˜¯stringä¹ˆï¼Œæ‡µäº†

  if (Array.isArray(vnode)) { // å¦‚æœç»“æœæ˜¯æ•°ç»„å½¢å¼ï¼Œç›´æ¥è¿”å›
    return vnode
  } else if (isDef(vnode)) { // å¦‚æœæ˜¯å•èŠ‚ç‚¹ï¼Œä¼šæ ¡éªŒnamespaceå’Œè¿½åŠ dataçš„ç»‘å®š
    if (isDef(ns)) applyNS(vnode, ns) // ä¸€å¼€å§‹çœ‹åˆ°è¿™ä¸ªapplyNSçš„æ—¶å€™æ˜¯æ‡µé€¼çš„ï¼Œåæ¥çœ‹äº†ä¸‹æ‰çŸ¥é“ï¼Œåº”è¯¥æ˜¯namespace
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}
```

åˆ°è¿™é‡Œåˆè¦å›åˆ° `render` æ–¹æ³•äº†ï¼Œ`createElement` æ–¹æ³•ä¸»è¦å°±æ˜¯è¿”å› VNodeï¼Œè™½ç„¶ä¹Ÿæœ‰ `createComponent`ï¼Œä½†æŒ‰ç…§ä»£ç ï¼ŒåŸºæœ¬éƒ½æ˜¯VNodeï¼Œå…ˆçœ‹ä¸€ä¸‹ VNode çš„æ„é€ å‡½æ•°ï¼Œç„¶åçœ‹ä¸€ä¸‹é»„è½¶æ˜¯æ€ä¹ˆè¯´çš„ã€‚

**VNode**

```js
class VNode {
  constructor (
    tag?: string, // åº”è¯¥æ˜¯tagå
    data?: VNodeData, // ç»‘å®šçš„dataï¼Ÿ
    children?: ?Array<VNode>, // ç›²çŒœå­èŠ‚ç‚¹
    text?: string, // æ˜¾ç¤ºçš„æ–‡æœ¬ï¼Ÿå¦‚æœæ˜¯ï¼Œä¸­é—´è¢«èŠ‚ç‚¹åˆ†éš”çš„å‘¢ï¼Ÿ
    elm?: Node, // å¯¹åº”çš„HTMLå…ƒç´ ?
    context?: Component, // åº”è¯¥æ˜¯ä¼ å…¥çš„vmå¯¹è±¡ï¼Ÿ
    // ä¸Šé¢ç”¨åˆ°çš„åˆ°è¿™é‡Œå°±æˆªæ­¢äº†
    componentOptions?: VNodeComponentOptions,
    asyncFactory?: Function
  ) {
    this.tag = tag
    this.data = data
    this.children = children
    this.text = text
    this.elm = elm
    this.ns = undefined
    this.context = context
    this.fnContext = undefined
    this.fnOptions = undefined
    this.fnScopeId = undefined
    this.key = data && data.key
    this.componentOptions = componentOptions
    this.componentInstance = undefined
    this.parent = undefined
    this.raw = false
    this.isStatic = false
    this.isRootInsert = true
    this.isComment = false
    this.isCloned = false
    this.isOnce = false
    this.asyncFactory = asyncFactory
    this.asyncMeta = undefined
    this.isAsyncPlaceholder = false
  }
}
```

åªçœ‹åˆ°è¿™ï¼Œå®Œå…¨ä¸æ‡‚è¿™ä¸ª Vnode çš„ä½œç”¨ï¼Œå¾—å»çœ‹é»„è½¶è®²çš„äº†ã€‚

å¦‚æœè¦äº†è§£ Virtual DOMï¼Œçœ‹[snabbdom](https://github.com/snabbdom/snabbdom)

> å…¶å® VNode æ˜¯å¯¹çœŸå® DOM çš„ä¸€ç§æŠ½è±¡æè¿°ï¼Œå®ƒçš„æ ¸å¿ƒå®šä¹‰æ— éå°±å‡ ä¸ªå…³é”®å±æ€§ï¼Œæ ‡ç­¾åã€æ•°æ®ã€å­èŠ‚ç‚¹ã€é”®å€¼ç­‰ï¼Œå…¶å®ƒå±æ€§éƒ½æ˜¯ç”¨æ¥æ‰©å±• VNode çš„çµæ´»æ€§ä»¥åŠå®ç°ä¸€äº›ç‰¹æ®Š feature çš„ã€‚

è¿™ä¸ªæ˜¯é»„è½¶çš„è§£é‡Šã€‚

> Virtual DOM é™¤äº†å®ƒçš„æ•°æ®ç»“æ„çš„å®šä¹‰ï¼Œæ˜ å°„åˆ°çœŸå®çš„ DOM å®é™…ä¸Šè¦ç»å† VNode çš„ createã€diffã€patch ç­‰è¿‡ç¨‹ã€‚é‚£ä¹ˆåœ¨ Vue.js ä¸­ï¼ŒVNode çš„ create æ˜¯é€šè¿‡ä¹‹å‰æåˆ°çš„ createElement æ–¹æ³•åˆ›å»ºçš„ï¼Œæˆ‘ä»¬æ¥ä¸‹æ¥åˆ†æè¿™éƒ¨åˆ†çš„å®ç°ã€‚

çœ‹è¿™æ®µæ–‡å­—ï¼Œæˆ‘çš„ç†è§£ï¼š
- createï¼Œæ ¹æ®VNodeé¦–æ¬¡å»åˆ›å»ºDOM
- diffï¼Œæ•°æ®æ›´æ–°æ—¶ï¼Œå»å¯¹æ¯”æ–°æ—§VNodeçš„å·®å¼‚
- patchï¼Œè¿™ä¸ªä¸çŸ¥é“æ˜¯ä¸æ˜¯å¯¹æ¯”å®Œåï¼Œæ›´æ–°å¯¹åº”VNodeï¼Œç„¶åæ›´æ–°å¯¹åº”DOMã€‚è¿˜æ˜¯è¯´æœ¬èº«æ–°æ—§å°±æ˜¯ä¸¤ä¸ªVNodeï¼Œç„¶åå¯¹æ¯”å…¶ä¸­æœ‰å·®åˆ«çš„åœ°æ–¹ï¼Œç„¶åå¯¹åº”ä¿®æ”¹DOMçš„ç›¸åº”éƒ¨åˆ†ã€‚


**é»„è½¶çš„createElementéƒ¨åˆ†**

> `data` è¡¨ç¤º `VNode` çš„æ•°æ®ï¼Œå®ƒæ˜¯ä¸€ä¸ª `VNodeData` ç±»å‹ï¼Œå¯ä»¥åœ¨ `flow/vnode.js` ä¸­æ‰¾åˆ°å®ƒçš„å®šä¹‰ï¼Œè¿™é‡Œå…ˆä¸å±•å¼€è¯´

è¿™ä¸ªåœ°æ–¹è‡ªå·±çœ‹åˆ°çš„æ—¶å€™ä¸æ˜¯ç‰¹åˆ«æ³¨æ„ã€‚æ‰€æœ‰çš„èŒƒå‹éƒ¨åˆ†ï¼Œæˆ‘éƒ½å¿½ç•¥è·³è¿‡äº†ã€‚

> `normalizationType` è¡¨ç¤ºå­èŠ‚ç‚¹è§„èŒƒçš„ç±»å‹ï¼Œç±»å‹ä¸åŒè§„èŒƒçš„æ–¹æ³•ä¹Ÿå°±ä¸ä¸€æ ·ï¼Œå®ƒä¸»è¦æ˜¯å‚è€ƒ `render` å‡½æ•°æ˜¯ç¼–è¯‘ç”Ÿæˆçš„è¿˜æ˜¯ç”¨æˆ·æ‰‹å†™çš„ã€‚

å¾ˆå¥½å¥‡ï¼Œé»„è½¶æ˜¯æ€ä¹ˆæ‰’å‡ºè¿™äº›é€»è¾‘çš„ã€‚

> `simpleNormalizeChildren` æ–¹æ³•è°ƒç”¨åœºæ™¯æ˜¯ `render` å‡½æ•°æ˜¯ç¼–è¯‘ç”Ÿæˆçš„ã€‚ç†è®ºä¸Šç¼–è¯‘ç”Ÿæˆçš„ `children` éƒ½å·²ç»æ˜¯ `VNode` ç±»å‹çš„ï¼Œä½†è¿™é‡Œæœ‰ä¸€ä¸ªä¾‹å¤–ï¼Œå°±æ˜¯ `functional component` å‡½æ•°å¼ç»„ä»¶è¿”å›çš„æ˜¯ä¸€ä¸ªæ•°ç»„è€Œä¸æ˜¯ä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œæ‰€ä»¥ä¼šé€šè¿‡ `Array.prototype.concat` æ–¹æ³•æŠŠæ•´ä¸ª `children` æ•°ç»„æ‰“å¹³ï¼Œè®©å®ƒçš„æ·±åº¦åªæœ‰ä¸€å±‚ã€‚

è¿™é‡Œç”¨ `concat` æ‰“å¹³ï¼Œä¸æ˜¯å¾ˆç†è§£ï¼Œå¯èƒ½éœ€è¦å†™ä¸ª demo è·‘ä¸€ä¸‹ï¼Ÿç®—äº†å§ï¼Œä¸å¯èƒ½çš„ã€‚

> è¿™é‡Œéœ€è¦æ³¨æ„ä¸€ç‚¹ï¼Œåœ¨éå†çš„è¿‡ç¨‹ä¸­ï¼Œå¯¹è¿™ 3 ç§æƒ…å†µéƒ½åšäº†å¦‚ä¸‹å¤„ç†ï¼šå¦‚æœå­˜åœ¨ä¸¤ä¸ªè¿ç»­çš„ `text` èŠ‚ç‚¹ï¼Œä¼šæŠŠå®ƒä»¬åˆå¹¶æˆä¸€ä¸ª `text` èŠ‚ç‚¹ã€‚

è®²çœŸçš„ï¼Œçœ‹è¿™ç§é€»è¾‘ä»£ç ï¼ŒçœŸçš„å¥½æ— èŠã€‚


> é‚£ä¹ˆè‡³æ­¤ï¼Œæˆ‘ä»¬å¤§è‡´äº†è§£äº† `createElement` åˆ›å»º `VNode` çš„è¿‡ç¨‹ï¼Œæ¯ä¸ª `VNode` æœ‰ `children`ï¼Œ`children` æ¯ä¸ªå…ƒç´ ä¹Ÿæ˜¯ä¸€ä¸ª `VNode`ï¼Œè¿™æ ·å°±å½¢æˆäº†ä¸€ä¸ª `VNode Tree`ï¼Œå®ƒå¾ˆå¥½çš„æè¿°äº†æˆ‘ä»¬çš„ `DOM Tree`ã€‚
>
> å›åˆ° `mountComponent` å‡½æ•°çš„è¿‡ç¨‹ï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“ `vm._render` æ˜¯å¦‚ä½•åˆ›å»ºäº†ä¸€ä¸ª `VNode`ï¼Œæ¥ä¸‹æ¥å°±æ˜¯è¦æŠŠè¿™ä¸ª `VNode` æ¸²æŸ“æˆä¸€ä¸ªçœŸå®çš„ `DOM` å¹¶æ¸²æŸ“å‡ºæ¥ï¼Œè¿™ä¸ªè¿‡ç¨‹æ˜¯é€šè¿‡ `vm._update` å®Œæˆçš„ï¼Œæ¥ä¸‹æ¥åˆ†æä¸€ä¸‹è¿™ä¸ªè¿‡ç¨‹ã€‚

æ ¹æ®é»„è½¶çš„æ€»ç»“ï¼ŒçŸ¥é“ `render` ä¸»è¦æ˜¯ç”Ÿæˆ VNode Treeï¼Œä½†æ˜¯è¿™æ ·ä¸‹æ¥ï¼Œå…¶å®é‡Œé¢çš„ç»†èŠ‚æ˜¯æ ¹æœ¬ä¸äº†è§£çš„ã€‚

ä¸‹é¢å°±è¦å›åˆ° `_update` éƒ¨åˆ†äº†ã€‚

**_update**

```js
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
  const vm: Component = this
  const prevEl = vm.$el
  const prevVnode = vm._vnode
  const restoreActiveInstance = setActiveInstance(vm)
  vm._vnode = vnode
  if (!prevVnode) {
    // é¦–æ¬¡
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
  } else {
    // æ›´æ–°ï¼Œä¼šèµ°diff
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  restoreActiveInstance()
  if (prevEl) {
    prevEl.__vue__ = null
  }
  if (vm.$el) {
    vm.$el.__vue__ = vm
  }
  // if parent is an HOC, update its $el as well
  // æ²¡æœ‰ç”¨è¿‡é«˜é˜¶ç»„ä»¶ï¼Œæˆ–è®¸ç”¨äº†ä½†æˆ‘ä¸çŸ¥é“
  if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
    vm.$parent.$el = vm.$el
  }
}
```

å…‰çœ‹è¿™æ®µä»£ç ï¼Œé‡ç‚¹åœ¨ä¸ `__patch__` æ–¹æ³•ï¼Œç„¶åå¯èƒ½è¿˜éœ€è¦äº†è§£ä¸€ä¸‹ `setActiveInstance` çš„ä½œç”¨ã€‚çœ‹ä¸€ä¸‹é»„è½¶æ˜¯æ€ä¹ˆè®²çš„ã€‚åº”è¯¥æ˜¯å¤§æ¦‚ä»‹ç»è¿™ä¸ª `_update` æ–¹æ³•åï¼Œå»ä»‹ç» `__patch__` çš„é€»è¾‘ã€‚

æœç„¶ã€‚

> `_update` çš„æ ¸å¿ƒå°±æ˜¯è°ƒç”¨ `vm.__patch__` æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•å®é™…ä¸Šåœ¨ä¸åŒçš„å¹³å°ï¼Œæ¯”å¦‚ web å’Œ weex ä¸Šçš„å®šä¹‰æ˜¯ä¸ä¸€æ ·çš„ï¼Œå› æ­¤åœ¨ web å¹³å°ä¸­å®ƒçš„å®šä¹‰åœ¨ `src/platforms/web/runtime/index.js` ä¸­ï¼š

åªæ˜¯å¤åˆ¶äº†è¿™æ®µè¯ï¼Œè‡ªå·±å…ˆæ‰¾ä¸€ä¸‹å®ç°ã€‚

è¿˜æ˜¯å¾ˆå¥½æ‰¾çš„ï¼Œå…¨å±€æœä¸€ä¸‹å°±æœ‰äº†ï¼Œæœ€åæ‰¾åˆ° `createPatchFunction`ã€‚è¿™ä¸ªæ–¹æ³•ä»£ç æœ‰ç‚¹å¤šï¼Œä¸€å…±æœ‰700å¤šè¡Œã€‚

> è¯¥æ–¹æ³•çš„å®šä¹‰æ˜¯è°ƒç”¨ `createPatchFunction` æ–¹æ³•çš„è¿”å›å€¼ï¼Œè¿™é‡Œä¼ å…¥äº†ä¸€ä¸ªå¯¹è±¡ï¼ŒåŒ…å« `nodeOps` å‚æ•°å’Œ `modules` `å‚æ•°ã€‚å…¶ä¸­ï¼ŒnodeOps` å°è£…äº†ä¸€ç³»åˆ— DOM `æ“ä½œçš„æ–¹æ³•ï¼Œmodules` å®šä¹‰äº†ä¸€äº›æ¨¡å—çš„é’©å­å‡½æ•°çš„å®ç°

é»„è½¶æ–‡ç« é‡Œçš„ `createPatchFunction` æ–¹æ³•çœç•¥äº†å¥½å¤šã€‚

æŠ˜å äº†æ‰€æœ‰çš„æ–¹æ³•å£°æ˜ä»¥åï¼Œå¯ä»¥çœ‹åˆ°æœ€åè¿”å›äº†ä¸€ä¸ª `patch` æ–¹æ³•ã€‚

åœ¨æ–¹æ³•çš„å¼€å§‹åšäº†ä¸€ä¸ª `call hooks`ï¼Œç„¶åå°±æ˜¯ç›´æ¥è¿”å›äº† `patch` æ–¹æ³•ï¼Œå…¶ä»–çš„éƒ½æ˜¯ä¸€äº›æ–¹æ³•å£°æ˜ï¼Œä»¥åŠéœ€è¦ç”¨åˆ°çš„å˜é‡å®šä¹‰ã€‚


æ–¹æ³•æ¯”è¾ƒé•¿ï¼Œä¸­é—´ç»å¸¸æ¥å›è·³è½¬çœ‹å…¶ä»–åœ°æ–¹çš„ä»£ç ï¼Œä¼šç»™å‰é¢çš„ä»£ç å¢åŠ ä¸€äº›æ³¨é‡Šï¼Œæ–‡ç« çš„å½¢å¼ä½“ç°ä¸å‡ºæ¥ã€‚

```js
// hydrating è¡¨ç¤ºæ˜¯å¦æ˜¯æœåŠ¡ç«¯æ¸²æŸ“
// removeOnly æ˜¯ç»™ transition-group ç”¨çš„
// ï¼ˆå‚è€ƒé»„è½¶çš„ä»‹ç»ï¼‰
// ä¸€ç›´æ‰¾ä¸‹å»ï¼Œå¯ä»¥çœ‹åˆ°ä¸‹é¢è¿™ä¸€æ®µæ³¨é‡Š
// removeOnly is a special flag used only by <transition-group>
// to ensure removed elements stay in correct relative positions
// during leaving transitions
function patch (oldVnode, vnode, hydrating, removeOnly) {
  // å¦‚æœæ²¡æœ‰æ–°vnodeï¼Œé‚£å°±æ˜¯èŠ‚ç‚¹è¢«ç§»é™¤äº†
  // é€’å½’è°ƒç”¨èŠ‚ç‚¹çš„ destroy é’©å­
  if (isUndef(vnode)) {
    if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
    return
  }

  let isInitialPatch = false
  const insertedVnodeQueue = []

  if (isUndef(oldVnode)) { // é¦–æ¬¡åˆ›å»ºï¼Œé»„è½¶çš„åº”è¯¥ä¼šç›´æ¥ä»‹ç»è¿™é‡Œå§
    isInitialPatch = true
    createElm(vnode, insertedVnodeQueue)
  } else {
    // ç”¨ nodeType ç¡®è®¤åŸç”ŸèŠ‚ç‚¹
    const isRealElement = isDef(oldVnode.nodeType)
    // sameVnode åº”è¯¥å°±æ˜¯åˆ¤æ–­æ–°æ—§èŠ‚ç‚¹çš„diffäº†
    // è¿™ä¸ªelseï¼Œæ™šç‚¹å†æ¥çœ‹
    // è·‘å»å†™æ–¹æ³•å‚æ•°çš„æ³¨é‡Šäº†
    // ä¸ºä»€ä¹ˆé»„è½¶çš„è®²è§£é‡Œï¼Œèµ°çš„æ˜¯è¿™ä¸ªæ–¹æ³•
    // é‡æ–°ç¡®è®¤äº†ä¸€ä¸‹å‚æ•°ï¼Œç¡®å®åº”è¯¥èµ°è¿™é‡Œ
    // patchçš„è°ƒç”¨ï¼Œçœ‹ä¸Šå»ä¼¼ä¹æ— è®ºå¦‚ä½•ï¼Œéƒ½ä¼šèµ°è¿™ä¸ªelse
    // é™¤é$elæ²¡æœ‰å®šä¹‰ï¼Œä½†æ˜¯ä»€ä¹ˆæ—¶å€™ä¼šæ²¡å®šä¹‰ï¼Œè¿™ä¸ªæš‚æ—¶æ‹ä¸æ¸…

    // å¤§æ¦‚çœ‹äº†ä¸‹sameVnodeçš„é€»è¾‘ï¼Œæš‚æ—¶å…ˆä¸ç®¡
    // emmmï¼Œä¼¼ä¹èµ°é”™é€»è¾‘äº†ï¼Œåº”è¯¥èµ° else
    // timeout
    if (!isRealElement && sameVnode(oldVnode, vnode)) {
      patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly)
    } else {
      if (isRealElement) {
        if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
          oldVnode.removeAttribute(SSR_ATTR)
          hydrating = true
        }
        if (isTrue(hydrating)) {
          if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
            invokeInsertHook(vnode, insertedVnodeQueue, true)
            return oldVnode
          } else if (process.env.NODE_ENV !== 'production') {
            warn(
              'The client-side rendered virtual DOM tree is not matching ' +
              'server-rendered content. This is likely caused by incorrect ' +
              'HTML markup, for example nesting block-level elements inside ' +
              '<p>, or missing <tbody>. Bailing hydration and performing ' +
              'full client-side render.'
            )
          }
        }
        // either not server-rendered, or hydration failed.
        // create an empty node and replace it
        oldVnode = emptyNodeAt(oldVnode)
      }

      // replacing existing element
      const oldElm = oldVnode.elm
      const parentElm = nodeOps.parentNode(oldElm)

      // create new node
      createElm(
        vnode,
        insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm,
        nodeOps.nextSibling(oldElm)
      )

      // update parent placeholder node element, recursively
      if (isDef(vnode.parent)) {
        let ancestor = vnode.parent
        const patchable = isPatchable(vnode)
        while (ancestor) {
          for (let i = 0; i < cbs.destroy.length; ++i) {
            cbs.destroy[i](ancestor)
          }
          ancestor.elm = vnode.elm
          if (patchable) {
            for (let i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, ancestor)
            }
            // #6513
            // invoke insert hooks that may have been merged by create hooks.
            // e.g. for directives that uses the "inserted" hook.
            const insert = ancestor.data.hook.insert
            if (insert.merged) {
              // start at index 1 to avoid re-invoking component mounted hook
              for (let i = 1; i < insert.fns.length; i++) {
                insert.fns[i]()
              }
            }
          } else {
            registerRef(ancestor)
          }
          ancestor = ancestor.parent
        }
      }

      // destroy old node
      if (isDef(parentElm)) {
        removeVnodes([oldVnode], 0, 0)
      } else if (isDef(oldVnode.tag)) {
        invokeDestroyHook(oldVnode)
      }
    }
  }

  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
  return vnode.elm
}
```